
<!DOCTYPE HTML>
<html lang="en-GB">
<head>
	<meta charset="utf-8">
	<title>me.toString();  | Han Ngo</title>

	<meta name="author" content="Han Ngo">

<meta name="description" content="Life Hacker and Lifelong Learner"> <meta name="keywords" content="nntruonghan, tieubao, tieubao blog, tieubao writing">

    <meta name="p:domain_verify" content="9cfd925a8a8bd39d7595ad0c077bddb3"/>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/notes/atom.xml" rel="alternate" title="Han Ngo" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/notes/favicon.png" rel="shortcut icon">
	<link href="/notes/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link rel="stylesheet" href="/notes/fancybox/jquery.fancybox.css" type="text/css" media="screen" />
<script type="text/javascript" src="/notes/fancybox/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el,
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	<!-- You can update Mapbox.js at https://www.mapbox.com/mapbox.js/ -->

<link href='//api.tiles.mapbox.com/mapbox.js/v1.5.0/mapbox.css' rel='stylesheet' />
<script src='//api.tiles.mapbox.com/mapbox.js/v1.5.0/mapbox.js'></script>
	 
 

 <!-- twitter card -->
 <meta name="twitter:card" content="summary">
 <meta name="twitter:site" content="@mrcexii">
 <meta name="twitter:creator" content="@mrcexii">
 <meta name="twitter:title" content="Han Ngo">
 <meta name="twitter:url" content="http://tieubao.github.io/notes/blog/page/6/">
 <meta name="twitter:description" content="Life Hacker and Lifelong Learner">

  <meta property="og:image" content="http://www.gravatar.com/avatar/1c5f4c2690dad0c1890bd3ec6263a296.png?s=200"> 

 <!--  -->



 <!-- open graph -->
 <meta property="og:title" content="Han Ngo"/>
 <meta property="og:type" content="blog"/>
 <meta property="og:url" content="http://tieubao.github.io/notes/blog/page/6/"/>
 <meta property="og:site_name" content="Han Ngo" />
<meta property="og:description" content="Life Hacker and Lifelong Learner" 
/>

 <meta property="og:image" content="http://www.gravatar.com/avatar/1c5f4c2690dad0c1890bd3ec6263a296.png?s=200"> 

<!--  -->

</head>


<body>
	<header id="header" class="inner"><h1><a href="/notes/">Han Ngo</a></h1>
<span class="tagline">me.toString();</span>
<!-- <nav id="main-nav"><ul>
	<li><a href="/notes/about">About</a></li>
	<li><a href="/notes/archives">Archives</a></li>
	<li><a href="/notes/contact">Contact</a></li>
</ul>
</nav> -->
<!-- <nav id="mobile-nav"> -->
<!-- 	<div class="alignleft menu"> -->
<!-- 		<a class="button">Menu</a> -->
<!-- 		<div class="container"><ul>
	<li><a href="/notes/about">About</a></li>
	<li><a href="/notes/archives">Archives</a></li>
	<li><a href="/notes/contact">Contact</a></li>
</ul>
</div> -->
<!-- 	</div> -->
<!-- </nav> -->


</header>

	<div id="content" class="inner">


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/git-rebase-vs-merge/">
			
				Rebase vs. Merge</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-05-10T15:55:37+07:00" pubdate data-updated="true">May 10<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p><img src="/notes/images/blog/2014-05-10-merge-rebase.png"></p>

<h1>What does Merge or Rebase mean?</h1>

<ul>
<li>Merging brings two lines of development together while preserving the ancestry of each commit history.</li>
<li>In contrast, rebasing unifies the lines of development by re-writing changes from the source branch so that they appear as children of the destination branch – effectively pretending that those commits were written on top of the destination branch all along.</li>
</ul>


<h4>Merging Pros</h4>

<ul>
<li>Simple to use and understand.</li>
<li>Maintains the original context of the source branch.</li>
<li>The commits on the source branch remain separate from other branch commits, provided you don’t perform a fast-forward merge. This separation can be useful in the case of feature branches, where you might want to take a feature and merge it into another branch later.</li>
<li>Existing commits on the source branch are unchanged and remain valid; it doesn’t matter if they’ve been shared with others.</li>
</ul>


<h4>Merging Cons</h4>

<ul>
<li>If the need to merge arises simply because multiple people are working on the same branch in parallel, the merges don’t serve any useful historic purpose and create clutter.</li>
</ul>


<h4>Rebase Pros</h4>

<ul>
<li>Simplifies your history.</li>
<li>Is the most intuitive and clutter-free way to combine commits from multiple developers in a shared branch</li>
</ul>


<h4>Rebase Cons</h4>

<ul>
<li>Slightly more complex, especially under conflict conditions. Each commit is rebased in order, and a conflict will interrupt the process of rebasing multiple commits. With a conflict, you have to resolve the conflict in order to continue the rebase. SourceTree guides you through this process, but it can still become a bit more complicated.</li>
<li>Rewriting of history has ramifications if you’ve previously pushed those commits elsewhere. In Mercurial, you simply cannot push commits that you later intend to rebase, because anyone pulling from the remote will get them. In Git, you may push commits you may want to rebase later (as a backup) but only if it’s to a remote branch that only you use. If anyone else checks out that branch and you later rebase it, it’s going to get very confusing.</li>
</ul>


<h1>Conclusion</h1>

<p>The consensus that I come across most frequently is that both merge and rebase are worth using. The time to use either is entirely dependent on the situation, the experience of your team, and the specific DVCS you’re using.</p>

<ol>
<li>When multiple developers work on a shared branch, pull &amp; rebase your outgoing commits to keep history cleaner (Git and Mercurial)</li>
<li>To re-integrate a completed feature branch, use merge (and opt-out of fast-forward commits in Git)</li>
<li>To bring a feature branch up to date with its base branch:

<ul>
<li>Prefer rebasing your feature branch onto the latest base branch if:

<ul>
<li>You haven’t pushed this branch anywhere yet, or</li>
<li>You’re using Git, and you know for sure that other people will not have checked out your feature branch</li>
</ul>
</li>
<li>Otherwise, merge the latest base changes into your feature branch</li>
</ul>
</li>
</ol>


<h4>Source: <a href="https://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/">https://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/</a></h4>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/git-branching-model/">
			
				Git Branching Model</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-05-08T16:20:24+07:00" pubdate data-updated="true">May 8<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p><img src="/notes/images/blog/2014-05-08-git-model.png"></p>

<p>In sort, you will organise your repository into 5 types of branches:</p>

<h3>The main branches</h3>

<ul>
<li><strong>master</strong>: the main branch where the source code of HEAD always reflects a <em>production-ready</em> state</li>
<li><strong>develop</strong>: the main branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the &ldquo;integration branch&rdquo;.</li>
</ul>


<h3>feature</h3>

<ul>
<li>May branch off from: develop</li>
<li>Must merge back into: develop</li>
<li>Branch naming convention: anything except master, develop, release-*, or hotfix-*</li>
</ul>


<p>Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point.</p>

<h3>release</h3>

<ul>
<li>May branch off from: develop</li>
<li>Must merge back into: develop and master</li>
<li>Branch naming convention: release-*</li>
</ul>


<p>Release branches are created from the develop branch. For example, say version 1.1.5 is the current production release and we have a big release coming up. The state of develop is ready for the “next release” and we have decided that this will become version 1.2 (rather than 1.1.6 or 2.0). So we branch off and give the release branch a name reflecting the new version number</p>

<h3>hotfix</h3>

<ul>
<li>May branch off from: master</li>
<li>Must merge back into: develop and master</li>
<li>Branch naming convention: hotfix-*</li>
</ul>


<p>Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.</p>

<h1>Summary</h1>

<p>While there is nothing really shocking new to this branching model, the &ldquo;big picture&rdquo; figure that this post began with has turned out to be tremendously useful in our projects. It forms an elegant mental model that is easy to comprehend and allows team members to develop a shared understanding of the branching and releasing processes.</p>

<h4>Source: <a href="http://nvie.com/posts/a-successful-git-branching-model/">Vincent Driessen</a></h4>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/hau-yeu/">
			
				Hậu Yêu (Yêu Từ đằng Sau?!)</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-02-23T01:03:01+07:00" pubdate data-updated="true">Feb 23<span>rd</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p><em>(Không dành cho trẻ em dưới 27 tuổi)</em></p>

<p>Nhân hôm nay đi đám cưới chị của người-đang-yêu, về gặp ngay ông (tên) anh cũng đang gặp chút vất vả trong tình cảm nên cũng tranh thủ đặt ngón chia sẻ một tí quan điểm cá nhân.</p>

<p>Bài báo bên dưới<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> tôi đọc cách đây 3 năm hơn nhưng vẫn rất tâm đắc, phần vì văn phong rất logic và dẩm, phần vì nó nói đúng với suy nghĩ của tôi.</p>

<p>Yêu nhau, vấn đề nào mà người bên ngoài nhìn vào cảm thấy không hợp nhãn thì tự dưng thành vấn đề to như gốc cây mù u, từ tuổi tác (nó hơn mày đến 10 tuổi, 2 đứa bằng tuổi thì thiệt thòi cho con) cho đến vóc dáng (em mập hơn nó những 20 cân thì sau này sao nó <code>cân</code> em nổi hay lùn thế thì cái ấy nó dài 30 cen không?)</p>

<p>Những cặp không yêu nhau, mới yêu nhau, hoặc yêu chưa đủ lâu, không biết tại sao mình yêu nó, không biết tại sao nó yêu mình, khi gặp những cái nhìn soi mói từ mọi người xung quanh, những lời bàn tán, những cản trở từ gia đình, hay cao hơn lúc họ vượt qua được tất cả thì khi gặp ngay cơn <code>bão chán</code> đang cuồng cuộng lao đến, mới quay lại tự hỏi nhau: thế rốt cuộc mình có/còn yêu nó không?</p>

<p>Cuộc đời là một cuộc hành trình dài, ngoài những thứ phải chuẩn bị như tư trang, kĩ năng hay tài chính &hellip; thì mỗi người, cần tìm cho mình một người vợ hoặc chồng mà các cụ hay ví von, người bạn đời. Vậy làm sao biết mình đã gặp đúng người bạn đời theo tiêu chuẩn 5-sao-Tiểu-Bảo? Ngoài những điều mà mọi người thường gọi là tình yêu, là có duyên, là hợp, yếu tố quan trọng nhất vẫn là chất dính. Là nước bọt. Là sở thích chung. Nói như Dâu Tây:</p>

<p>&ldquo;Tình yêu như là tổ chim. Niềm đam mê là chú chim. Sở thích chung là nước bọt con chim. Sự nhàm chán là trận mưa. Khi trời mưa chú chim sẽ bay xa bắt con giun. Nếu tổ chim xây tốt, tức chú chim dùng nhiều nước bọt làm chất dính, thì lúc chú chim bay về tổ vẫn còn. Chú chim sẽ đậu xuống ăn mấy con giun vừa bắt để nước bọt càng thêm hiệu quả.</p>

<p>Tuy nhiên nếu xây không được tốt, nước bọt ít quá, tổ chim là sẽ bị phá mất, chú chim bay về không thấy chỗ đậu xuống sẽ bay tiếp.</p>

<p>Trong so sánh mới này yếu tố quan trọng nhất vẫn là chất dính. Là nước bọt. Là sở thích chung. Tất nhiên cặp đôi yêu nhau nào cũng phải có “duyên”, hoặc điều tiếng Anh gọi là “chemistry” – là “tính phản ứng” khó giải thích nhưng dễ cảm nhận, khiến hai người đến với nhau lúc đầu. Nhưng điều đó thuộc họ mê, gia đình phê.</p>

<p>Sở thích chung luôn là chính và có thể được thể hiện bằng nhiều cách. Có những cặp đôi rất thích cãi nhau. Với họ, cảm giác bị điên (hoặc làm người ta bị điên) là sở thích chung. Họ cãi nhau suốt bao nhiêu năm trời khiến bà hàng xóm tự hỏi vì sao họ chưa giết nhau. Nhưng điều bà hàng xóm chưa biết là mỗi lần xa nhau hơn một tuần là cả hai đều thấy buồn vô cùng.&#8221;</p>

<p>Cuộc đời vẫn là một cuộc hành trình dài, hôn nhân diễn ra giống như bạn vừa công bố đã tìm được một người bạn đời và cầm trên tay một cái vé tàu hỏa. Chính thức, nghiêm túc và vui vẻ có người bạn đời bên cạnh bước lên toa tàu để cùng nhau khám phá đoạn hành trình còn lại. Hôn nhân chưa phải là điểm dừng.</p>

<p>Người bạn đời, đối với riêng tôi, bỏ hết tất cả những phù phiếm xung quanh, có thể có lúc sẽ cãi nhau như chó mèo, có lúc cùng nhau làm những việc siêu điên khùng vui vẻ, có lúc gặp <code>bão chán</code> thì chán hẳn nhưng phải đảm bảo luôn ở bên cạnh nhau. Vì chán không phải là hết yêu.</p>

<p>Vậy nên khi bạn mở miệng thốt lên câu: &ldquo;anh muốn sống/đi với em trọn cuộc đời này&rdquo; thì cũng nên cân nhắc kĩ một tí, đừng vì chút lý do cá nhân nào đó (đừng vì một ít tiền, một vài cái lỗ, hay vì bác sĩ bảo cưới) mà vội quyết định, cuộc đời này chỉ có một.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Joe &ndash; <a href="http://dantri.com.vn/blog/phong-chan-chua-chan-441455.htm">Phòng chán chữa chán</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>


		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/quy-trinh/">
			
				Quy Trình</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-02-17T14:27:16+07:00" pubdate data-updated="true">Feb 17<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p>Ngày còn ngồi ở giảng đường, tôi thường chú ý rất nhiều vào các quy trình phát triển phần mềm. Đối với một quốc gia đang tự hào về ngành gia công phần mềm (outsourcing) chúng tôi được dạy rất nhiều từ các quy trình cổ điển nhất như <code>Waterfall Model</code> cho đến những quy trình được coi là theo kịp thời đại nhất như <code>Scrum</code> để có thể nhanh chóng gia nhập vào đội ngũ lập trình viên của các công ty đã có tên tuổi trên thị trường. Bài viết này không đề cập nhiều đến vấn đề gia công phần mềm mà thay vào đó tập trung nói đến sự quan trọng của quy trình trong việc phát triển phần mềm.</p>

<p>Về bản chất, các quy trình phần mềm đều tập trung vào việc quy đổi trách nhiệm và giải quyết sự chênh lệch giữa 2 giai đoạn quan trọng nhất: <code>quản lý yêu cầu</code> và <code>phát triển phần mềm</code>. Các giai đoạn này có thể được chia nhỏ ra theo chiều ngang/dọc thành các giai đoạn con nhỏ hơn và đôi khi có sự tham gia của các stakeholder không trực tiếp thuộc quy trình phát triển. Việc đưa ra và tuân thủ theo các quy trình phát triển phần mềm là rất tốt cho một nhóm đã vững chắc.</p>

<p><img src="/notes/images/blog/2014-02-17-software-dev-agile-process.png"></p>

<p>Tuy nhiên, đối với các nhóm nhỏ với số lượng thành viên từ 3 &ndash; 9 người, việc tuân theo một quy trình với quá nhiều quy tắt chặt chẽ sẽ làm chậm lại việc phát triển phần mềm một cách đáng kể. Theo cảm nhận của bản thân tôi trong suốt 4 dự án đã tham gia, trung bình mỗi người phải mất khoảng <code>20 - 40%</code> toàn thời gian cho việc chuẩn bị các tài liệu và chuyển giao công việc giữa các bộ phận. Điều này không hẳn là bất lợi, nhưng đối với một nhóm start-up, một công ty nhỏ thì đây là những chi phí không đáng phải tiêu tốn. Đối với một start-up, nhóm nhỏ, điều quan trọng nhất là đưa được sản phẩm có giá trị ra thị trường tiêu thụ càng nhanh càng tốt, điều đó giúp tăng cơ hội sống sót của start-up.</p>

<p>Chính vì lý do đó mà hầu hết các start-up đều đi theo sự linh hoạt của triết lí phát triển phần mềm Agile. Trong đó đề cao sự quan trọng của con người,  khách hàng và sự ngầm hiểu (<a href="http://en.wikipedia.org/wiki/Tacit_knowledge"><code>tacit knowledge</code></a>). Các loại tài liệu không cần thiết ở thời điểm hiện tại hoặc các phần kiến thức mà các thành viên trong nhóm đã biết hoặc hiểu rõ có thể được lược giản để giảm bớt các buổi họp không cần thiết, những buổi thảo luận nhàm chán &hellip; và dồn thời gian vào việc phát triển một sản phẩm hoàn chỉnh. Việc này có thể là tốt hoặc xấu dựa trên các quan điểm khác nhau, nhưng với các yếu tố được nêu ở trên thì nếu có một nhóm với trình độ và kiến thức (giỏi) ngang nhau, chúng ta sẽ dễ dàng một chút hơn trong việc xây dựng một nhóm kết dính (<code>jelly team</code>).</p>

<p><img src="/notes/images/blog/2014-02-17-team.jpg"></p>

<p>Quy trình và cách làm việc đóng một vai trò rất quan trọng nhưng chưa phải là tất cả các yếu tố cần thiết và đầy đủ để xây dựng một team vững mạnh. Ngoài cách làm việc giữa mọi người trong nhóm, còn cần phải tìm hiểu thêm về tính cách riêng, định hướng nghề nghiệp, khả năng bản thân và quan điểm sống của từng thành viên &hellip; Nói đến đây có lẽ mọi người sẽ nghĩ đây chỉ là việc mà một trưởng dự án cần quan tâm, một lập trình viên thì chỉ cần quan tâm đến công việc của mình là đủ. Điều này hoàn toàn không đúng. Khi bạn tham gia vào một dự án, việc đóng góp và cố gắng hòa mình xây dựng một nhóm bền vững sẽ giúp bạn dễ dàng hơn trong việc trao đổi thông tin, giúp đỡ và nhận sự giúp đỡ từ các thành viên khác, trong công việc và cả trong cuộc sống.</p>

<blockquote><p>Easy life, easy win.</p></blockquote>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/training-android-day03-04/">
			
				Training Android: Day 03 and 04</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-02-16T18:18:11+07:00" pubdate data-updated="true">Feb 16<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p>Thai studied faster than my expectation. At 3rd and 4th day, I give him some oop presentations from <code>mr. nmhuy</code> about <code>polymorphism</code> and <code>inheritance</code>.</p>

<p>Every time he got problem or something went wrong, we work remotely through TeamViewer and Skype. Exercises was assigned through Trello cards.</p>

<h5>Agenda</h5>

<ul>
<li>polymorphism in oop</li>
<li>inheritance in oop</li>
<li>exercises about them</li>
</ul>


		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/training-android-day-02/">
			
				Training Android: Day 02</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-02-13T23:22:37+07:00" pubdate data-updated="true">Feb 13<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p>Thai is the only come to us on 2nd day. Because of his windows lappy cannot run Visual C or CodeBlock, I decide to teach him linux and git before continuing on OOP. Hope he will become IT geek in someday.</p>

<h5>Agenda:</h5>

<ul>
<li>Install Lubuntu</li>
<li>Setup Trello</li>
<li>Basic Linux command and practice</li>
<li>Try to run sample code on CodeBlock on Linux environment</li>
</ul>


		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/training-android-day-01/">
			
				Training Android: Day 01</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-02-10T23:15:40+07:00" pubdate data-updated="true">Feb 10<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p>Today, two friends of mine join our company training program. This course is all about Android.</p>

<p>Nam is senior student and studying Software Engineering major at HCM University of Science. The problem is with another guy, Thai. He is a graduated from Physics major with a little experience in Matlab.</p>

<p>Today is just a first day. I still have a long journey with those guy. Good luck to me.</p>

<h5>Agenda:</h5>

<ul>
<li>Eclipse and GenyMotion</li>
<li>HelloWorld app</li>
<li>Android project overview</li>
<li>Sample app: Fill in a textbox and alert the content</li>
</ul>


<p>For Thai:</p>

<ul>
<li>C basic</li>
<li>Tools and how to debug</li>
<li>OOP concept</li>
</ul>


		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/semantic-versioning-2-dot-0-0/">
			
				Semantic Versioning 2.0.0</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-01-09T13:03:30+07:00" pubdate data-updated="true">Jan 9<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<h2>Summary</h2>

<p>Given a version number MAJOR.MINOR.PATCH, increment the:</p>

<ol>
<li>MAJOR version when you make incompatible API changes,</li>
<li>MINOR version when you add functionality in a backwards-compatible
manner, and</li>
<li>PATCH version when you make backwards-compatible bug fixes.</li>
</ol>


<p>Additional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.</p>

<h2>Introduction</h2>

<p>In the world of software management there exists a dread place called
&ldquo;dependency hell.&rdquo; The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.</p>

<p>In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.</p>

<p>As a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.</p>

<p>I call this system &ldquo;Semantic Versioning.&rdquo; Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.</p>

<h2>Why Use Semantic Versioning?</h2>

<p>This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that &ldquo;close&rdquo; isn&rsquo;t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.</p>

<p>A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called &ldquo;Firetruck.&rdquo; It requires a
Semantically Versioned package named &ldquo;Ladder.&rdquo; At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.</p>

<p>As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there&rsquo;s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.</p>

<p>If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.</p>

<h2>FAQ</h2>

<h3>How should I deal with revisions in the 0.y.z initial development phase?</h3>

<p>The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.</p>

<h3>How do I know when to release 1.0.0?</h3>

<p>If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you&rsquo;re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.</p>

<h3>Doesn&rsquo;t this discourage rapid development and fast iteration?</h3>

<p>Major version zero is all about rapid development. If you&rsquo;re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.</p>

<h3>If even the tiniest backwards incompatible changes to the public API require a major version bump, won&rsquo;t I end up at version 42.0.0 very rapidly?</h3>

<p>This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you&rsquo;ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.</p>

<h3>Documenting the entire public API is too much work!</h3>

<p>It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that&rsquo;s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.</p>

<h3>What do I do if I accidentally release a backwards incompatible change as a minor version?</h3>

<p>As soon as you realize that you&rsquo;ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it&rsquo;s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.</p>

<h3>What should I do if I update my own dependencies without changing the public API?</h3>

<p>That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it&rsquo;s obviously a minor level increment.</p>

<h3>What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)</h3>

<p>Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.</p>

<h3>How should I handle deprecating functionality?</h3>

<p>Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.</p>

<h3>Does SemVer have a size limit on the version string?</h3>

<p>No, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.</p>

<h4>Source: <a href="http://semver.org/">Semver</a></h4>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/readme-driven-development/">
			
				Readme Driven Development</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-01-09T12:44:56+07:00" pubdate data-updated="true">Jan 9<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p>I hear a lot of talk these days about TDD and BDD and Extreme Programming and SCRUM and stand up meetings and all kinds of methodologies and techniques for developing better software, but it&rsquo;s all irrelevant unless the software we&rsquo;re building meets the needs of those that are using it. Let me put that another way. A perfect implementation of the wrong specification is worthless. By the same principle a beautifully crafted library with no documentation is also damn near worthless. If your software solves the wrong problem or nobody can figure out how to use it, there&rsquo;s something very bad going on.</p>

<p>Fine. So how do we solve this problem? It&rsquo;s easier than you think, and it&rsquo;s important enough to warrant its very own paragraph.</p>

<p>Write your Readme first.</p>

<p>First. As in, before you write any code or tests or behaviors or stories or ANYTHING. I know, I know, we&rsquo;re programmers, dammit, not tech writers! But that&rsquo;s where you&rsquo;re wrong. Writing a Readme is absolutely essential to writing good software. Until you&rsquo;ve written about your software, you have no idea what you&rsquo;ll be coding. Between The Great Backlash Against Waterfall Design and The Supreme Acceptance of Agile Development, something was lost. Don&rsquo;t get me wrong, waterfall design takes things way too far. Huge systems specified in minute detail end up being the WRONG systems specified in minute detail. We were right to strike it down. But what took its place is too far in the other direction. Now we have projects with short, badly written, or entirely missing documentation. Some projects don&rsquo;t even have a Readme!</p>

<p>This is not acceptable. There must be some middle ground between reams of technical specifications and no specifications at all. And in fact there is. That middle ground is the humble Readme.</p>

<p>It&rsquo;s important to distinguish Readme Driven Development from Documentation Driven Development. RDD could be considered a subset or limited version of DDD. By restricting your design documentation to a single file that is intended to be read as an introduction to your software, RDD keeps you safe from DDD-turned-waterfall syndrome by punishing you for lengthy or overprecise specification. At the same time, it rewards you for keeping libraries small and modularized. These simple reinforcements go a long way towards driving your project in the right direction without a lot of process to ensure you do the right thing.</p>

<p>By writing your Readme first you give yourself some pretty significant advantages:</p>

<ul>
<li><p>Most importantly, you&rsquo;re giving yourself a chance to think through the project without the overhead of having to change code every time you change your mind about how something should be organized or what should be included in the Public API. Remember that feeling when you first started writing automated code tests and realized that you caught all kinds of errors that would have otherwise snuck into your codebase? That&rsquo;s the exact same feeling you&rsquo;ll have if you write the Readme for your project before you write the actual code.</p></li>
<li><p>As a byproduct of writing a Readme in order to know what you need to implement, you&rsquo;ll have a very nice piece of documentation sitting in front of you. You&rsquo;ll also find that it&rsquo;s much easier to write this document at the beginning of the project when your excitement and motivation are at their highest. Retroactively writing a Readme is an absolute drag, and you&rsquo;re sure to miss all kinds of important details when you do so.</p></li>
<li><p>If you&rsquo;re working with a team of developers you get even more mileage out of your Readme. If everyone else on the team has access to this information before you&rsquo;ve completed the project, then they can confidently start work on other projects that will interface with your code. Without any sort of defined interface, you have to code in serial or face reimplementing large portions of code.</p></li>
<li><p>It&rsquo;s a lot simpler to have a discussion based on something written down. It&rsquo;s easy to talk endlessly and in circles about a problem if nothing is ever put to text. The simple act of writing down a proposed solution means everyone has a concrete idea that can be argued about and iterated upon.</p></li>
</ul>


<p>Consider the process of writing the Readme for your project as the true act of creation. This is where all your brilliant ideas should be expressed. This document should stand on its own as a testament to your creativity and expressiveness. The Readme should be the single most important document in your codebase; writing it first is the proper thing to do.</p>

<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>

<h4>source: <a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">tpw</a></h4>

<p>=======</p>

<h4>Source: <a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">Tom Preston-Werner</a></h4>

<blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>775de3eac255d0394388a65a3e9aadc8a9c7bcd2</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/notes/a/how-to-meet-your-next-cofounder/">
			
				How to Meet Your Next Cofounder</a>
		</h2>
		<div class="meta date">








  


<time datetime="2014-01-09T12:16:33+07:00" pubdate data-updated="true">Jan 9<span>th</span>, 2014</time></div>
	</header>
	<div class="entry-content">
		<p>Over the last few months I’ve seen a number of people looking for cofounders on Hacker News or via their own personal blogs. I think this is, at best, a highly inefficient way to find a cofounder and, at worst, a way to fool yourself into finding the wrong cofounder. In any case, it’s a naive approach to finding the person that will need to stand by your side in the coming storm that we call “running a startup.”</p>

<p>Don’t get me wrong, the internet is an amazing tool for meeting people. The wider the net you cast, the more likely you are to find the perfect match. But the internet has its limitations. I’ve had internet friends that were engaging, witty, and brilliant online, but in person felt awkward and boring. Conversely, I know people that are volatile and inflammatory online, but present an attitude of friendliness and caring in person. This phenomenon makes it difficult to gauge an individual’s personality from online interaction alone.</p>

<p>A far better use of the internet is to find groups of people that share your interests. Track down the local users group for your language or technology of choice. The simple fact that members of these groups take time out of their day to show up means that they’re more motivated and driven than the average person. Even if it’s a bit of a commute to get to the meetings, start showing up regularly. Prepare a few presentations on topics that you’re passionate about. Bonus points if you present on ideas related to your potential startup. Don’t worry about revealing your game-changing secrets; stealth mode is bullshit. Talk to everyone. Steer the conversation toward your interests and if someone there is excited about the same things, it will be clear.</p>

<p>It may take weeks or months, but in a good group you’ll find a handful of people that you really like. If at all possible, go out drinking with these people after the meetups. This is one of the easiest ways to go from “acquaintance” to “friend” and gives you free license to bring up your craziest of ideas without sounding like too much of a nutjob.</p>

<p>Of the people that you like, several may make excellent candidates for cofounders. Do a little research on these individuals. What does their code look like? Have they done much open source? Do they demonstrate an entrepreneurial spirit? Can they stick with a single project for a long time? Have they been loyal to their friends and companies in the past? A good cofounder should be someone with whom you feel privileged to work. And they should feel privileged to work with you. The two of you should be on very solid ground before you begin your startup adventure, because once you do, the impact of every argument is going to feel like it’s been multiplied by a thousand.</p>

<p>This all sounds like a lot of hard work. Maybe you’re wondering if it would be better to just go solo. I did that with Gravatar, and, in retrospect, it’s painfully obvious that I made a lot of stupid mistakes. When it’s just you and your thoughts it becomes too easy to pick the first thing that pops into your head. We’re programmed to think all of our ideas are good, but reality tells a different story. Truly good decisions are forged from the furnace of argument, not plucked like daisies from the pasture of a peaceful mind. A good cofounder tells you when your ideas are half-baked and ensures that your good ideas actually get implemented.</p>

<p>The second biggest danger with going solo is the loss of motivation. Solipsism might make you feel important at first, but the constant lack of feedback and the absence of support during tough times can easily lead to a premature end to your adventure. Cofounders are like workout buddies. Just when you think there’s no possible way you can do another rep, there they are, rooting you on toward an achievement that wouldn’t be possible without them.</p>

<p>Your choice of cofounder will affect everything you do in your startup. They’ll share every defeat with you and celebrate every success. They’ll help you understand your own ideas better by offering a different perspective. They’ll be the single most important decision you make during the tenure of your startup, so choose wisely and with extreme care.</p>

<h4>source: <a href="http://tom.preston-werner.com/2008/11/03/how-to-meet-your-next-cofounder.html">tpw</a></h4>

		
		
	</div>

</article>

<nav id="pagenavi">
    
        <a href="/notes/blog/page/5/" class="prev">Previous</a>
    
    
        <a href="/notes/blog/page/7/" class="next">Next</a>
    
</nav>
</div>
	<footer id="footer" class="inner"><br>
<br>
<br>
<br>
&copy; 2020

    Han Ngo

</footer>
	<script src="/notes/javascripts/slash.js"></script>
<script src="/notes/javascripts/hyphenator.js"></script>





	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-57628334-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>




</body>
<script>
  $(document).ready(function() {
  // Make images center
  $('p:has(img)').css('text-align', 'center');
  });
</script>
</html>
